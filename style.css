// 可爱版互动圣诞树 - 前端完整逻辑（无后端）
// 功能：拖拽贴纸、点击放置、可移动装饰、匿名留言（本地保存）、雪花动画、截图导出

// -------------- 常量与初始 ----------------
const STICKERS = [
  { id:'star', label:'星星', svg: `<svg viewBox="0 0 24 24" width="56" height="56"><path fill="#ffd86b" d="M12 2l2.9 6.2L21 9l-5 3.8L17.8 20 12 16.6 6.2 20 7 12.8 2 9l6.1-0.8L12 2z"/></svg>` },
  { id:'ball', label:'彩球', svg: `<svg viewBox="0 0 24 24" width="56" height="56"><circle cx="12" cy="12" r="8" fill="#ff9fc3"/><rect x="10" y="3" width="4" height="3" rx="1" fill="#fff"/></svg>` },
  { id:'lamp', label:'灯串', svg: `<svg viewBox="0 0 24 24" width="56" height="56"><path d="M3 6c7 6 11 6 18 0" stroke="#ffdf6b" stroke-width="2" fill="none"/><circle cx="6" cy="9" r="1.6" fill="#ff9fc3"/><circle cx="12" cy="8.6" r="1.6" fill="#b6f0d4"/><circle cx="18" cy="9.2" r="1.6" fill="#ffd86b"/></svg>` },
  { id:'gift', label:'礼物', svg: `<svg viewBox="0 0 24 24" width="56" height="56"><rect x="3" y="7" width="18" height="10" rx="1.6" fill="#b6f0d4"/><path d="M12 7v10" stroke="#ff9fc3" stroke-width="1.6"/><path d="M8 4c1.6 1.6 3 2 4 2s2.4-0.4 4-2" stroke="#ff9fc3" stroke-width="1.6" fill="none"/></svg>` },
  { id:'snow', label:'雪球', svg: `<svg viewBox="0 0 24 24" width="56" height="56"><circle cx="12" cy="12" r="7" fill="#fff"/><circle cx="9" cy="10" r="1.4" fill="#dfe9ff"/><circle cx="15" cy="14" r="1.4" fill="#dfe9ff"/></svg>` },
];

// DOM
const canvasWrap = document.querySelector('.tree-wrap');
const canvas = document.getElementById('treeCanvas');
const ctx = canvas.getContext('2d');
const stickersDiv = document.getElementById('stickers');
const dropHint = document.getElementById('dropHint');
const msgArea = document.getElementById('msgArea');
const msgText = document.getElementById('msgText');
const sendMsg = document.getElementById('sendMsg');
const clearBtn = document.getElementById('clearBtn');
const exportBtn = document.getElementById('exportBtn');

// data (存在 localStorage)
let decorations = JSON.parse(localStorage.getItem('ct_decor')) || []; // {id,x,y,stickerId}
let messages = JSON.parse(localStorage.getItem('ct_msgs')) || []; // {id,text,x,y}

// -------------- 画树基础 ----------------
function drawTreeBase(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // 背景浅色渐变已由 CSS, 这里只画树形
  // 绘制三个绿色层次
  const g = ctx;
  g.save();
  g.translate(0,0);
  g.fillStyle = '#7acb73';
  g.beginPath();
  g.moveTo(210,40);
  g.lineTo(90,240);
  g.lineTo(330,240);
  g.closePath();
  g.fill();
  g.fillStyle = '#5fb564';
  g.beginPath();
  g.moveTo(210,120);
  g.lineTo(70,320);
  g.lineTo(350,320);
  g.closePath();
  g.fill();
  g.fillStyle = '#3fa24a';
  g.beginPath();
  g.moveTo(210,200);
  g.lineTo(50,440);
  g.lineTo(370,440);
  g.closePath();
  g.fill();
  // 树干
  g.fillStyle = '#8b5a2b';
  g.fillRect(190,440,40,70);
  g.restore();
}
drawTreeBase();

// scale canvas for hi-dpi displays
function fixDPR(){
  const ratio = window.devicePixelRatio || 1;
  const w = canvas.clientWidth || 420;
  const h = canvas.clientHeight || 640;
  canvas.width = Math.round(w * ratio);
  canvas.height = Math.round(h * ratio);
  canvas.style.width = w + 'px';
  canvas.style.height = h + 'px';
  ctx.setTransform(ratio,0,0,ratio,0,0);
  drawTreeBase();
}
fixDPR();
window.addEventListener('resize',fixDPR);

// -------------- 生成右侧贴纸按钮 ----------------
function buildStickerPalette(){
  STICKERS.forEach(s=>{
    const btn = document.createElement('button');
    btn.className = 'sticker-btn';
    btn.innerHTML = s.svg;
    btn.title = s.label;
    btn.draggable = true;
    btn.dataset.sid = s.id;
    // 拖拽开始
    btn.addEventListener('dragstart', (ev)=>{
      ev.dataTransfer.setData('text/sticker', JSON.stringify(s));
      ev.dataTransfer.effectAllowed = 'copy';
    });
    // 点击放置（中央位置）
    btn.addEventListener('click', ()=>{
      placeSticker({x:canvas.width/ (window.devicePixelRatio||1) /2, y:canvas.height/(window.devicePixelRatio||1)/2}, s.id);
    });
    stickersDiv.appendChild(btn);
  });
}
buildStickerPalette();

// -------------- 放置 & 渲染 装饰（以 DOM 元素覆盖在 canvas 上，可拖动） --------------
function renderDecorations(){
  // 清除已有 DOM decorations
  document.querySelectorAll('.decoration').forEach(n=>n.remove());
  decorations.forEach(d=>{
    const el = document.createElement('div');
    el.className = 'decoration';
    el.style.left = d.x + 'px';
    el.style.top = d.y + 'px';
    el.dataset.id = d.id;
    const sticker = STICKERS.find(s=>s.id===d.stickerId);
    el.innerHTML = sticker ? sticker.svg : '';
    el.style.zIndex = 60;
    canvasWrap.appendChild(el);

    // 绑定拖动（移动装饰）
    makeDraggable(el, (nx,ny)=>{
      d.x = nx; d.y = ny;
      saveState();
    });

    // 双击删除
    el.addEventListener('dblclick', ()=>{
      decorations = decorations.filter(dd=>dd.id!==d.id);
      saveState();
      renderDecorations();
    });
  });
}

// -------------- 拖放支持画布 ----------------
canvasWrap.addEventListener('dragover', (e)=>{
  e.preventDefault();
  dropHint.style.opacity = 1;
});
canvasWrap.addEventListener('dragleave', (e)=>{
  dropHint.style.opacity = .7;
});
canvasWrap.addEventListener('drop', (e)=>{
  e.preventDefault();
  dropHint.style.opacity = .2;
  const data = e.dataTransfer.getData('text/sticker');
  if(!data) return;
  const s = JSON.parse(data);
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  placeSticker({x,y}, s.id);
});

// 点击在树上放置（点击坐标）
canvas.addEventListener('click', (e)=>{
  const rect = canvas.getBoundingClientRect();
  const x = e.clientX - rect.left;
  const y = e.clientY - rect.top;
  // 默认放随机贴纸或球
  placeSticker({x,y}, STICKERS[Math.floor(Math.random()*STICKERS.length)].id);
});

// place a sticker object
function placeSticker(pos, stickerId){
  const id = 'd_'+Date.now()+'_'+Math.floor(Math.random()*999);
  const d = { id, x: pos.x, y: pos.y, stickerId };
  decorations.push(d);
  saveState();
  renderDecorations();
}

// make element draggable within canvasWrap
function makeDraggable(el, onmove){
  let dragging=false, offsetX=0, offsetY=0;
  el.addEventListener('pointerdown', (ev)=>{
    ev.preventDefault();
    dragging = true;
    el.setPointerCapture(ev.pointerId);
    const r = el.getBoundingClientRect();
    offsetX = ev.clientX - r.left;
    offsetY = ev.clientY - r.top;
    el.style.cursor='grabbing';
  });
  el.addEventListener('pointermove', (ev)=>{
    if(!dragging) return;
    const rect = canvasWrap.getBoundingClientRect();
    let nx = ev.clientX - rect.left - offsetX + el.clientWidth/2;
    let ny = ev.clientY - rect.top - offsetY + el.clientHeight/2;
    // limit inside canvasWrap
    nx = Math.max(8, Math.min(rect.width-8, nx));
    ny = Math.max(8, Math.min(rect.height-8, ny));
    el.style.left = nx + 'px';
    el.style.top = ny + 'px';
    onmove && onmove(nx, ny);
  });
  el.addEventListener('pointerup', (ev)=>{
    dragging=false;
    el.releasePointerCapture && el.releasePointerCapture(ev.pointerId);
    el.style.cursor='grab';
  });
}

// -------------- 消息漂浮 ----------------
function renderMessages(){
  msgArea.innerHTML = '';
  messages.forEach(m=>{
    const card = document.createElement('div');
    card.className = 'msg-card';
    card.textContent = m.text;
    const del = document.createElement('span'); del.className='del'; del.textContent='✖';
    del.title='删除（仅本地）';
    del.addEventListener('click', ()=>{
      messages = messages.filter(mm=>mm.id!==m.id);
      saveState();
      renderMessages();
    });
    card.appendChild(del);
    msgArea.appendChild(card);
  });
}

// -------------- 发送消息 ----------------
sendMsg.addEventListener('click', ()=>{
  const text = msgText.value.trim();
  if(!text) return;
  const id = 'm_'+Date.now();
  const m = { id, text };
  messages.unshift(m);
  if(messages.length>12) messages.pop();
  msgText.value='';
  saveState();
  renderMessages();
  // 也在树周围显示漂浮卡片（临时）
  spawnFloating(m);
});

// floating card near tree
function spawnFloating(m){
  const el = document.createElement('div');
  el.className='msg-card';
  el.textContent = m.text;
  canvasWrap.appendChild(el);
  // random position near tree center
  const r = canvas.getBoundingClientRect();
  const x = (r.width/2) + (Math.random()*140-70);
  const y = (r.height/2) + (Math.random()*140-80);
  el.style.position='absolute';
  el.style.left = x+'px';
  el.style.top = y+'px';
  el.style.opacity=0;
  setTimeout(()=>el.style.opacity=1,50);
  setTimeout(()=>{ el.style.transition='transform 800ms ease, opacity 600ms'; el.style.transform='translateY(-40px)'; el.style.opacity=0; }, 2500);
  setTimeout(()=>el.remove(),3300);
}

// -------------- 保存与恢复 state ----------------
function saveState(){
  localStorage.setItem('ct_decor', JSON.stringify(decorations));
  localStorage.setItem('ct_msgs', JSON.stringify(messages));
}
function loadState(){
  renderDecorations();
  renderMessages();
}
loadState();

// -------------- 清空 ----------------
clearBtn.addEventListener('click', ()=>{
  if(!confirm('确认清空所有装饰与留言？（此操作不可恢复，仅清除本地数据）')) return;
  decorations = [];
  messages = [];
  saveState();
  renderDecorations();
  renderMessages();
});

// -------------- 截图导出（下载 canvas 与 overlay 装饰合成图） ----------------
exportBtn.addEventListener('click', async ()=>{
  // create an offscreen canvas
  const w = canvas.width / (window.devicePixelRatio||1);
  const h = canvas.height / (window.devicePixelRatio||1);
  const off = document.createElement('canvas');
  off.width = w; off.height = h;
  const g = off.getContext('2d');
  // draw tree (recreate)
  // simple approach: draw tree shapes like drawTreeBase
  g.fillStyle = '#7acb73';
  g.beginPath(); g.moveTo(210,40); g.lineTo(90,240); g.lineTo(330,240); g.closePath(); g.fill();
  g.fillStyle = '#5fb564'; g.beginPath(); g.moveTo(210,120); g.lineTo(70,320); g.lineTo(350,320); g.closePath(); g.fill();
  g.fillStyle = '#3fa24a'; g.beginPath(); g.moveTo(210,200); g.lineTo(50,440); g.lineTo(370,440); g.closePath(); g.fill();
  g.fillStyle = '#8b5a2b'; g.fillRect(190,440,40,70);
  // draw decorations by rendering their SVGs to dataURL then drawImage
  const promises = decorations.map(d=>{
    const sticker = STICKERS.find(s=>s.id===d.stickerId);
    if(!sticker) return Promise.resolve();
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="112" height="112" viewBox="0 0 24 24">${sticker.svg.replace(/<svg[^>]*>|<\/svg>/g,'')}</svg>`;
    const blob = new Blob([svg], {type:'image/svg+xml;charset=utf-8'});
    const url = URL.createObjectURL(blob);
    return new Promise(res=>{
      const img = new Image();
      img.onload = ()=>{ g.drawImage(img, d.x-28, d.y-28, 56,56); URL.revokeObjectURL(url); res(); };
      img.src = url;
    });
  });
  await Promise.all(promises);
  // download
  const a = document.createElement('a');
  a.href = off.toDataURL('image/png');
  a.download = 'cute_christmas_tree.png';
  a.click();
});

// -------------- 简单雪花动画 ----------------
const snowRoot = document.getElementById('snow');
function spawnSnow(){
  const s = document.createElement('div');
  s.className='snowflake';
  s.textContent='❄';
  const startX = Math.random()*window.innerWidth;
  const size = 12 + Math.random()*12;
  s.style.fontSize = size+'px';
  s.style.left = startX+'px';
  s.style.top = '-40px';
  s.style.opacity = 0.8 + Math.random()*0.2;
  snowRoot.appendChild(s);
  const duration = 4000 + Math.random()*4000;
  const endX = startX + (Math.random()*120-60);
  s.animate([
    { transform:`translateY(0px) translateX(0px)`, opacity: s.style.opacity},
    { transform:`translateY(${window.innerHeight+80}px) translateX(${endX-startX}px)`, opacity:0.6}
  ], { duration, easing:'linear' });
  setTimeout(()=>s.remove(), duration+50);
}
setInterval(spawnSnow, 350);

// -------------- helpers ----------------
function uid(prefix='u'){ return prefix+Math.random().toString(36).slice(2,9); }

// initial render decorations after DOM ready
renderDecorations();
renderMessages();
